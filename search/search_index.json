{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spatial K Spatial K is a set of libraries for working with geospatial data in Kotlin including an implementation of GeoJson and a port of Turfjs written in pure Kotlin. It supports Kotlin Multiplatform projects and also features a Kotlin DSL for building GeoJson objects. Installation Java and Kotlin/JVM dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" implementation \"io.github.dellisd.spatialk:turf:<version>\" } Kotlin Multiplatform commonMain { dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" implementation \"io.github.dellisd.spatialk:turf:<version>\" } } Snapshots Snapshot builds are available on Sonatype. repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" } } Supported targets Spatial K currently supports the following platform targets: jvm , js , mingwX64 , linuxX64 , macosX64 , iosX64 , iosArm64 , and iosArm32 .","title":"Introduction"},{"location":"#spatial-k","text":"Spatial K is a set of libraries for working with geospatial data in Kotlin including an implementation of GeoJson and a port of Turfjs written in pure Kotlin. It supports Kotlin Multiplatform projects and also features a Kotlin DSL for building GeoJson objects.","title":"Spatial K"},{"location":"#installation","text":"","title":"Installation"},{"location":"#java-and-kotlinjvm","text":"dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" implementation \"io.github.dellisd.spatialk:turf:<version>\" }","title":"Java and Kotlin/JVM"},{"location":"#kotlin-multiplatform","text":"commonMain { dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" implementation \"io.github.dellisd.spatialk:turf:<version>\" } }","title":"Kotlin Multiplatform"},{"location":"#snapshots","text":"Snapshot builds are available on Sonatype. repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" } }","title":"Snapshots"},{"location":"#supported-targets","text":"Spatial K currently supports the following platform targets: jvm , js , mingwX64 , linuxX64 , macosX64 , iosX64 , iosArm64 , and iosArm32 .","title":"Supported targets"},{"location":"geojson-dsl/","text":"GeoJson DSL The geojson-dsl library provides a Kotlin DSL for constructing GeoJson objects from the geojson library. Installation dependencies { implementation \"io.github.dellisd.spatialk:geojson-dsl:0.1.0\" } DSL Geometry Each geometry type has a corresponding DSL. A GeoJson object's bbox value can be assigned in any of the DSLs. Point Kotlin point ( longitude = - 75.0 , latitude = 45.0 , altitude = 100.0 ) JSON { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] } MultiPoint The MultiPoint DSL uses the unary plus operator to add Position instances as positions in the geometry. This means that it is possible to add Point objects as well as LngLat objects as positions to a MultiPoint . Kotlin multiPoint { + point ( - 75.0 , 45.0 ) + LngLat ( - 78.0 , 44.0 ) } JSON { \"type\" : \"MultiPoint\" , \"coordinates\" : [ [ -75.0 , 45.0 ], [ -78.0 , 44.0 ] ] } LineString Like with MultiPoint , the LineString DSL uses the unary plus operator to add positions as part of the line. The order in which positions are added to the LineString is the order that the LineString will follow. Kotlin lineString { + LngLat ( 45.0 , 45.0 ) + LngLat ( 0.0 , 0.0 ) } JSON { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] } MultiLineString The MultiLineString DSL uses the unary plus operator to add multiple line strings. The LineString DSL can be used to create LineString objects to add. Kotlin val simpleLine = lineString { + LngLat ( 45.0 , 45.0 ) + LngLat ( 0.0 , 0.0 ) } multiLineString { + simpleLine // Inline LineString creation + lineString { + LngLat ( 44.4 , 55.5 ) + LngLat ( 55.5 , 66.6 ) } } JSON { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]], [[ 44.4 , 55.5 ], [ 55.5 , 66.6 ]] ] } Polygon The Polygon DSL is used by specifying linear rings that make up the polygon's shape and holes. The first ring is the exterior ring with four or more positions. The last position must be the same as the first position. All ring s that follow will represent interior rings (i.e. holes) in the polygon. For convenience, the complete() function can be used to \"complete\" a ring. It adds the last position in the ring by copying the first position that was added. Kotlin val simpleLine = lineString { + LngLat ( 45.0 , 45.0 ) + LngLat ( 0.0 , 0.0 ) } polygon { ring { // LineStrings can be used as part of a ring + simpleLine + LngLat ( 12.0 , 12.0 ) complete () } ring { + LngLat ( 4.0 , 4.0 ) + LngLat ( 2.0 , 2.0 ) + LngLat ( 3.0 , 3.0 ) complete () } } JSON { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] } MultiPolygon Like with previous \"Multi\" geometries, the unary plus operator is used to add multipl Polygon objects. The Polygon DSL can also be used here. Kotlin val simplePolygon = previousExample () multiPolygon { + simplePolygon + polygon { ring { + LngLat ( 12.0 , 0.0 ) + LngLat ( 0.0 , 12.0 ) + LngLat ( - 12.0 , 0.0 ) + LngLat ( 5.0 , 5.0 ) complete () } } } JSON { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ], [ [[ 12.0 , 0.0 ], [ 0.0 , 12.0 ], [ -12.0 , 0.0 ], [ 5.0 , 5.0 ], [ 12.0 , 0.0 ]] ] ] } Geometry Collection The unary plus operator can be used to add any geometry to a GeometryCollection . Kotlin val simplePoint : Point = previousPoint () val simpleLine : LineString = previousLineString () val simplePolygon : Polygon = previousPolygon () geometryCollection { + simplePoint + simpleLine + simplePolygon } JSON { \"type\" : \"GeometryCollection\" , \"geometries\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] }, { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] } ] } Feature The Feature DSL can construct a Feature object with a geometry, a set of properties, a bounding box, and an id. Kotlin feature { geometry = point ( - 75.0 , 45.0 ) id = \"point1\" bbox = BoundingBox ( - 76.9 , 44.1 , - 74.2 , 45.7 ) properties { \"name\" to \"Hello World\" \"value\" to 13 \"cool\" to true } } JSON { \"type\" : \"Feature\" , \"id\" : \"point1\" , \"bbox\" : [ -76.9 , 44.1 , -74.2 , 45.7 ], \"properties\" : { \"name\" : \"Hello World\" , \"value\" : 13 , \"cool\" : true }, \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] } } Feature Collection A FeatureCollection is constructed by adding multiple Feature objects using the unary plus operator. Kotlin featureCollection { + feature { geometry = point ( - 75.0 , 45.0 ) } } JSON { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] }, \"properties\" : {} } ] }","title":"GeoJson DSL"},{"location":"geojson-dsl/#geojson-dsl","text":"The geojson-dsl library provides a Kotlin DSL for constructing GeoJson objects from the geojson library.","title":"GeoJson DSL"},{"location":"geojson-dsl/#installation","text":"dependencies { implementation \"io.github.dellisd.spatialk:geojson-dsl:0.1.0\" }","title":"Installation"},{"location":"geojson-dsl/#dsl","text":"","title":"DSL"},{"location":"geojson-dsl/#geometry","text":"Each geometry type has a corresponding DSL. A GeoJson object's bbox value can be assigned in any of the DSLs.","title":"Geometry"},{"location":"geojson-dsl/#point","text":"Kotlin point ( longitude = - 75.0 , latitude = 45.0 , altitude = 100.0 ) JSON { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] }","title":"Point"},{"location":"geojson-dsl/#multipoint","text":"The MultiPoint DSL uses the unary plus operator to add Position instances as positions in the geometry. This means that it is possible to add Point objects as well as LngLat objects as positions to a MultiPoint . Kotlin multiPoint { + point ( - 75.0 , 45.0 ) + LngLat ( - 78.0 , 44.0 ) } JSON { \"type\" : \"MultiPoint\" , \"coordinates\" : [ [ -75.0 , 45.0 ], [ -78.0 , 44.0 ] ] }","title":"MultiPoint"},{"location":"geojson-dsl/#linestring","text":"Like with MultiPoint , the LineString DSL uses the unary plus operator to add positions as part of the line. The order in which positions are added to the LineString is the order that the LineString will follow. Kotlin lineString { + LngLat ( 45.0 , 45.0 ) + LngLat ( 0.0 , 0.0 ) } JSON { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] }","title":"LineString"},{"location":"geojson-dsl/#multilinestring","text":"The MultiLineString DSL uses the unary plus operator to add multiple line strings. The LineString DSL can be used to create LineString objects to add. Kotlin val simpleLine = lineString { + LngLat ( 45.0 , 45.0 ) + LngLat ( 0.0 , 0.0 ) } multiLineString { + simpleLine // Inline LineString creation + lineString { + LngLat ( 44.4 , 55.5 ) + LngLat ( 55.5 , 66.6 ) } } JSON { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]], [[ 44.4 , 55.5 ], [ 55.5 , 66.6 ]] ] }","title":"MultiLineString"},{"location":"geojson-dsl/#polygon","text":"The Polygon DSL is used by specifying linear rings that make up the polygon's shape and holes. The first ring is the exterior ring with four or more positions. The last position must be the same as the first position. All ring s that follow will represent interior rings (i.e. holes) in the polygon. For convenience, the complete() function can be used to \"complete\" a ring. It adds the last position in the ring by copying the first position that was added. Kotlin val simpleLine = lineString { + LngLat ( 45.0 , 45.0 ) + LngLat ( 0.0 , 0.0 ) } polygon { ring { // LineStrings can be used as part of a ring + simpleLine + LngLat ( 12.0 , 12.0 ) complete () } ring { + LngLat ( 4.0 , 4.0 ) + LngLat ( 2.0 , 2.0 ) + LngLat ( 3.0 , 3.0 ) complete () } } JSON { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] }","title":"Polygon"},{"location":"geojson-dsl/#multipolygon","text":"Like with previous \"Multi\" geometries, the unary plus operator is used to add multipl Polygon objects. The Polygon DSL can also be used here. Kotlin val simplePolygon = previousExample () multiPolygon { + simplePolygon + polygon { ring { + LngLat ( 12.0 , 0.0 ) + LngLat ( 0.0 , 12.0 ) + LngLat ( - 12.0 , 0.0 ) + LngLat ( 5.0 , 5.0 ) complete () } } } JSON { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ], [ [[ 12.0 , 0.0 ], [ 0.0 , 12.0 ], [ -12.0 , 0.0 ], [ 5.0 , 5.0 ], [ 12.0 , 0.0 ]] ] ] }","title":"MultiPolygon"},{"location":"geojson-dsl/#geometry-collection","text":"The unary plus operator can be used to add any geometry to a GeometryCollection . Kotlin val simplePoint : Point = previousPoint () val simpleLine : LineString = previousLineString () val simplePolygon : Polygon = previousPolygon () geometryCollection { + simplePoint + simpleLine + simplePolygon } JSON { \"type\" : \"GeometryCollection\" , \"geometries\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] }, { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] } ] }","title":"Geometry Collection"},{"location":"geojson-dsl/#feature","text":"The Feature DSL can construct a Feature object with a geometry, a set of properties, a bounding box, and an id. Kotlin feature { geometry = point ( - 75.0 , 45.0 ) id = \"point1\" bbox = BoundingBox ( - 76.9 , 44.1 , - 74.2 , 45.7 ) properties { \"name\" to \"Hello World\" \"value\" to 13 \"cool\" to true } } JSON { \"type\" : \"Feature\" , \"id\" : \"point1\" , \"bbox\" : [ -76.9 , 44.1 , -74.2 , 45.7 ], \"properties\" : { \"name\" : \"Hello World\" , \"value\" : 13 , \"cool\" : true }, \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] } }","title":"Feature"},{"location":"geojson-dsl/#feature-collection","text":"A FeatureCollection is constructed by adding multiple Feature objects using the unary plus operator. Kotlin featureCollection { + feature { geometry = point ( - 75.0 , 45.0 ) } } JSON { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] }, \"properties\" : {} } ] }","title":"Feature Collection"},{"location":"geojson/","text":"GeoJson The geojson module contains an implementation of the GeoJson standard . See below for constructing GeoJson objects using the DSL. Installation Kotlin dependencies { implementation ( \"io.github.dellisd.spatialk:geojson:<version>\" ) } Groovy dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" } GeoJson Objects The GeoJson interface represents all GeoJson objects. All GeoJson objects can have a bbox property specified on them which is a BoundingBox that represents the bounds of that object's geometry. Geometry Geometry objects are a sealed hierarchy of classes that inherit from the Geometry class. This allows for exhaustive type checks in Kotlin using a when block. Kotlin val geometry : Geometry = getGeometry () val type = when ( geometry ) { is Point -> \"Point\" is MultiPoint -> \"MultiPoint\" is LineString -> \"LineString\" is MultiLineString -> \"MultiLineString\" is Polygon -> \"Polygon\" is MultiPolygon -> \"MultiPolygon\" is GeometryCollection -> \"GeometryCollection\" } All seven types of GeoJSON geometries are implemented and summarized below. Full documentation can be found in the API pages . Position Positions are implemented as a DoubleArray -backed class. Each component ( longitude , latitude , altitude ) can be accessed by its propery. The class also supports destructuring. Positions are implemented as an interface where the longitude, latitude, and optionally an altitude are accessible as properties. The basic implementation of the Position interface is the LngLat class. Kotlin val position : Position = Position ( - 75.0 , 45.0 ) val ( longitude , latitude , altitude ) = position // Access values position . longitude position . latitude position . altitude // null if unspecified JSON [ -75 , 45 ] Point A Point is a single Position. Kotlin val point = Point ( Position ( - 75.0 , 45.0 )) println ( point . longitude ) // Prints: -75.0 JSON { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] } MultiPoint A MultiPoint is an array of Positions. Kotlin val multiPoint = MultiPoint ( Position ( - 75.0 , 45.0 ), Position ( - 79.0 , 44.0 )) JSON { \"type\" : \"MultiPoint\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] } LineString A LineString is a sequence of two or more Positions. Kotlin val lineString = LineString ( Position ( - 75.0 , 45.0 ), Position ( - 79.0 , 44.0 )) JSON { \"type\" : \"LineString\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] } MultiLineString A MultiLineString is an array of LineStrings. Kotlin val multiLineString = MultiLineString ( listOf ( Position ( 12.3 , 45.6 ), Position ( 78.9 , 12.3 )), listOf ( Position ( 87.6 , 54.3 ), Position ( 21.9 , 56.4 )) ) JSON { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 12.3 , 45.6 ], [ 78.9 , 12.3 ]], [[ 87.6 , 54.3 ], [ 21.9 , 56.4 ]] ] } Polygon A Polygon is an array of rings. Each ring is a sequence of points with the last point matching the first point to indicate a closed area. The first ring defines the outer shape of the polygon, while all the following rings define \"holes\" inside the polygon. Kotlin val polygon = Polygon ( listOf ( Position ( - 79.87 , 43.42 ), Position ( - 78.89 , 43.49 ), Position ( - 79.07 , 44.02 ), Position ( - 79.95 , 43.87 ), Position ( - 79.87 , 43.42 ) ), listOf ( Position ( - 79.75 , 43.81 ), Position ( - 79.56 , 43.85 ), Position ( - 79.7 , 43.88 ), Position ( - 79.75 , 43.81 ) ) ) JSON { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ] } MultiPolygon A MultiPolygon is an array of Polygons. Kotlin val polygon = listOf ( Position ( - 79.87 , 43.42 ), Position ( - 78.89 , 43.49 ), Position ( - 79.07 , 44.02 ), Position ( - 79.95 , 43.87 ), Position ( - 79.87 , 43.42 ) ), listOf ( Position ( - 79.75 , 43.81 ), Position ( - 79.56 , 43.85 ), Position ( - 79.7 , 43.88 ), Position ( - 79.75 , 43.81 ) ) val multiPolygon = MultiPolygon ( polygon , polygon ) JSON { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ], [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ] ] } GeometryCollection A GeometryCollection is a collection of different types of Geometry. It implements the Collection interface and can be used in any place that a collection can be used. Kotlin val geometryCollection = GeometryCollection ( point , lineString ) // Can be iterated over, and used in any way a Collection<T> can be geometryCollection . forEach { geometry -> // ... } JSON { \"type\" : \"GeometryCollection\" , \"coordinates\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] } ] } Feature A Feature can contain a Geometry object, as well as a set of data properties, and optionally a commonly used identifier ( id ). A feature's properties are stored as a map of JsonElement objects from kotlinx.serialization . A set of helper methods to get and set properties with the appropriate types directly. Kotlin val feature = Feature ( point ) feature . setNumberProperty ( \"size\" , 9999 ) val size : Number? = feature . getNumberProperty ( \"size\" ) // 9999 val geometry : Geometry? = feature . geometry // point JSON { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, \"properties\" : { \"size\" : 9999 } } FeatureCollection A FeatureCollection is a collection of multiple features. FeatureCollection implements the Collection interface and can be used in any place that a collection can be used. Kotlin val featureCollection = FeatureCollection ( pointFeature ) featureCollection . forEach { feature -> // ... } JSON { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, \"properties\" : { \"size\" : 9999 } } ] } BoundingBox The BoundingBox class is used to represent the bounding boxes that can be set for any GeoJson object. Like the Position class, bounding boxes are backed by a DoubleArray with each component accessible by its propery ( southwest and northeast ). Bounding boxes also support destructuring. Kotlin val bbox = BoundingBox ( west = 11.6 , south = 45.1 , east = 12.7 , north = 45.7 ) val ( southwest , northeast ) = bbox // Two Positions JSON [ 11.6 , 45.1 , 12.7 , 45.7 ] Serialization Serialization is done using kotlinx.serialization and the serializer for any object listed above can be obtained using the static .serializer() method. The Geometry sealed class hierarchy uses a polymorphic serializer, so the serializer for all types of geometry are simply obtained from Geometry.serializer() . To Json Any GeoJson object can be serialized to Json using the json property. Kotlin val featureCollection : FeatureCollection = getFeatureCollection () val json = featureCollection . json println ( json ) From Json Json strings can be converted to GeoJson objects using various methods. Geometry Geometry can be converted from Json using generic functions that will automatically deserialize the given Json into the appropriate Geometry subclass. In Kotlin, these functions are available as extension functions on a String . In Java, these functions are available as static methods on GeometryFactory . Kotlin // Throws exception if the JSON cannot be deserialized to a Point val myPoint = \"{...geojson...}\" . toGeometry < Point > () // Returns null if an error occurs val nullable = \"{...not a point...}\" . toGeometryOrNull < Point > () Feature and FeatureCollection Feature and FeatureCollection objects can be converted from Json similarly. Kotlin val feature = \"{...feature...}\" . toFeature () val featureCollection = \"{...feature collection...}\" . toFeatureCollection () GeoJson DSL It's recommended to construct GeoJson objects in-code using the included DSL. Positions Convenience functions to construct latitude/longitude Position instances is included. These functions will check for valid latitude and longitude values and will throw an IllegalArgumentException otherwise. Kotlin lngLat ( longitude = - 75.0 , latitude = 45.0 ) // Throws exception!! lngLat ( longitude = - 565.0 , latitude = 45.0 ) JSON [ -75.0 , 45.0 ] Geometry Each geometry type has a corresponding DSL. A GeoJson object's bbox value can be assigned in any of the DSLs. Point Kotlin point ( longitude = - 75.0 , latitude = 45.0 , altitude = 100.0 ) // Or... point ( Position ( 12.5 , 35.9 )) JSON { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] } MultiPoint The MultiPoint DSL uses the unary plus operator to add Position instances as positions in the geometry. Point geometries can also be added to the multi point using the unary plus operator. Kotlin multiPoint { + point ( - 75.0 , 45.0 ) + lngLat ( - 78.0 , 44.0 ) } JSON { \"type\" : \"MultiPoint\" , \"coordinates\" : [ [ -75.0 , 45.0 ], [ -78.0 , 44.0 ] ] } LineString Like with MultiPoint , the LineString DSL uses the unary plus operator to add positions as part of the line. The order in which positions are added to the LineString is the order that the LineString will follow. Kotlin lineString { + lngLat ( 45.0 , 45.0 ) + lngLat ( 0.0 , 0.0 ) } JSON { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] } MultiLineString The MultiLineString DSL uses the unary plus operator to add multiple line strings. The LineString DSL can be used to create LineString objects to add. Kotlin val simpleLine = lineString { + lngLat ( 45.0 , 45.0 ) + lngLat ( 0.0 , 0.0 ) } multiLineString { + simpleLine // Inline LineString creation + lineString { + lngLat ( 44.4 , 55.5 ) + lngLat ( 55.5 , 66.6 ) } } JSON { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]], [[ 44.4 , 55.5 ], [ 55.5 , 66.6 ]] ] } Polygon The Polygon DSL is used by specifying linear rings that make up the polygon's shape and holes. The first ring is the exterior ring with four or more positions. The last position must be the same as the first position. All ring s that follow will represent interior rings (i.e. holes) in the polygon. For convenience, the complete() function can be used to \"complete\" a ring. It adds the last position in the ring by copying the first position that was added. Kotlin val simpleLine = lineString { + lngLat ( 45.0 , 45.0 ) + lngLat ( 0.0 , 0.0 ) } polygon { ring { // LineStrings can be used as part of a ring + simpleLine + lngLat ( 12.0 , 12.0 ) complete () } ring { + lngLat ( 4.0 , 4.0 ) + lngLat ( 2.0 , 2.0 ) + lngLat ( 3.0 , 3.0 ) complete () } } JSON { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] } MultiPolygon Like with previous \"Multi\" geometries, the unary plus operator is used to add multiple Polygon objects. The Polygon DSL can also be used here. Kotlin val simplePolygon = previousExample () multiPolygon { + simplePolygon + polygon { ring { + LngLat ( 12.0 , 0.0 ) + LngLat ( 0.0 , 12.0 ) + LngLat ( - 12.0 , 0.0 ) + LngLat ( 5.0 , 5.0 ) complete () } } } JSON { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ], [ [[ 12.0 , 0.0 ], [ 0.0 , 12.0 ], [ -12.0 , 0.0 ], [ 5.0 , 5.0 ], [ 12.0 , 0.0 ]] ] ] } Geometry Collection The unary plus operator can be used to add any geometry instance to a GeometryCollection . Kotlin val simplePoint : Point = previousPoint () val simpleLine : LineString = previousLineString () val simplePolygon : Polygon = previousPolygon () geometryCollection { + simplePoint + simpleLine + simplePolygon } JSON { \"type\" : \"GeometryCollection\" , \"geometries\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] }, { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] } ] } Feature The Feature DSL can construct a Feature object with a geometry, a set of properties, a bounding box, and an id. Kotlin feature { geometry = point ( - 75.0 , 45.0 ) id = \"point1\" bbox = BoundingBox ( - 76.9 , 44.1 , - 74.2 , 45.7 ) properties { \"name\" to \"Hello World\" \"value\" to 13 \"cool\" to true } } JSON { \"type\" : \"Feature\" , \"id\" : \"point1\" , \"bbox\" : [ -76.9 , 44.1 , -74.2 , 45.7 ], \"properties\" : { \"name\" : \"Hello World\" , \"value\" : 13 , \"cool\" : true }, \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] } } Feature Collection A FeatureCollection is constructed by adding multiple Feature objects using the unary plus operator. Kotlin featureCollection { + feature { geometry = point ( - 75.0 , 45.0 ) } } JSON { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] }, \"properties\" : {} } ] }","title":"GeoJson"},{"location":"geojson/#geojson","text":"The geojson module contains an implementation of the GeoJson standard . See below for constructing GeoJson objects using the DSL.","title":"GeoJson"},{"location":"geojson/#installation","text":"Kotlin dependencies { implementation ( \"io.github.dellisd.spatialk:geojson:<version>\" ) } Groovy dependencies { implementation \"io.github.dellisd.spatialk:geojson:<version>\" }","title":"Installation"},{"location":"geojson/#geojson-objects","text":"The GeoJson interface represents all GeoJson objects. All GeoJson objects can have a bbox property specified on them which is a BoundingBox that represents the bounds of that object's geometry.","title":"GeoJson Objects"},{"location":"geojson/#geometry","text":"Geometry objects are a sealed hierarchy of classes that inherit from the Geometry class. This allows for exhaustive type checks in Kotlin using a when block. Kotlin val geometry : Geometry = getGeometry () val type = when ( geometry ) { is Point -> \"Point\" is MultiPoint -> \"MultiPoint\" is LineString -> \"LineString\" is MultiLineString -> \"MultiLineString\" is Polygon -> \"Polygon\" is MultiPolygon -> \"MultiPolygon\" is GeometryCollection -> \"GeometryCollection\" } All seven types of GeoJSON geometries are implemented and summarized below. Full documentation can be found in the API pages .","title":"Geometry"},{"location":"geojson/#position","text":"Positions are implemented as a DoubleArray -backed class. Each component ( longitude , latitude , altitude ) can be accessed by its propery. The class also supports destructuring. Positions are implemented as an interface where the longitude, latitude, and optionally an altitude are accessible as properties. The basic implementation of the Position interface is the LngLat class. Kotlin val position : Position = Position ( - 75.0 , 45.0 ) val ( longitude , latitude , altitude ) = position // Access values position . longitude position . latitude position . altitude // null if unspecified JSON [ -75 , 45 ]","title":"Position"},{"location":"geojson/#point","text":"A Point is a single Position. Kotlin val point = Point ( Position ( - 75.0 , 45.0 )) println ( point . longitude ) // Prints: -75.0 JSON { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }","title":"Point"},{"location":"geojson/#multipoint","text":"A MultiPoint is an array of Positions. Kotlin val multiPoint = MultiPoint ( Position ( - 75.0 , 45.0 ), Position ( - 79.0 , 44.0 )) JSON { \"type\" : \"MultiPoint\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] }","title":"MultiPoint"},{"location":"geojson/#linestring","text":"A LineString is a sequence of two or more Positions. Kotlin val lineString = LineString ( Position ( - 75.0 , 45.0 ), Position ( - 79.0 , 44.0 )) JSON { \"type\" : \"LineString\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] }","title":"LineString"},{"location":"geojson/#multilinestring","text":"A MultiLineString is an array of LineStrings. Kotlin val multiLineString = MultiLineString ( listOf ( Position ( 12.3 , 45.6 ), Position ( 78.9 , 12.3 )), listOf ( Position ( 87.6 , 54.3 ), Position ( 21.9 , 56.4 )) ) JSON { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 12.3 , 45.6 ], [ 78.9 , 12.3 ]], [[ 87.6 , 54.3 ], [ 21.9 , 56.4 ]] ] }","title":"MultiLineString"},{"location":"geojson/#polygon","text":"A Polygon is an array of rings. Each ring is a sequence of points with the last point matching the first point to indicate a closed area. The first ring defines the outer shape of the polygon, while all the following rings define \"holes\" inside the polygon. Kotlin val polygon = Polygon ( listOf ( Position ( - 79.87 , 43.42 ), Position ( - 78.89 , 43.49 ), Position ( - 79.07 , 44.02 ), Position ( - 79.95 , 43.87 ), Position ( - 79.87 , 43.42 ) ), listOf ( Position ( - 79.75 , 43.81 ), Position ( - 79.56 , 43.85 ), Position ( - 79.7 , 43.88 ), Position ( - 79.75 , 43.81 ) ) ) JSON { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ] }","title":"Polygon"},{"location":"geojson/#multipolygon","text":"A MultiPolygon is an array of Polygons. Kotlin val polygon = listOf ( Position ( - 79.87 , 43.42 ), Position ( - 78.89 , 43.49 ), Position ( - 79.07 , 44.02 ), Position ( - 79.95 , 43.87 ), Position ( - 79.87 , 43.42 ) ), listOf ( Position ( - 79.75 , 43.81 ), Position ( - 79.56 , 43.85 ), Position ( - 79.7 , 43.88 ), Position ( - 79.75 , 43.81 ) ) val multiPolygon = MultiPolygon ( polygon , polygon ) JSON { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ], [ [[ -79.87 , 43.42 ], [ -78.89 , 43.49 ], [ -79.07 , 44.02 ], [ -79.95 , 43.87 ], [ -79.87 , 43.42 ]], [[ -79.75 , 43.81 ], [ -79.56 , 43.85 ], [ -79.7 , 43.88 ], [ -79.75 , 43.81 ]] ] ] }","title":"MultiPolygon"},{"location":"geojson/#geometrycollection","text":"A GeometryCollection is a collection of different types of Geometry. It implements the Collection interface and can be used in any place that a collection can be used. Kotlin val geometryCollection = GeometryCollection ( point , lineString ) // Can be iterated over, and used in any way a Collection<T> can be geometryCollection . forEach { geometry -> // ... } JSON { \"type\" : \"GeometryCollection\" , \"coordinates\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ -75 , 45 ], [ -79 , 44 ]] } ] }","title":"GeometryCollection"},{"location":"geojson/#feature","text":"A Feature can contain a Geometry object, as well as a set of data properties, and optionally a commonly used identifier ( id ). A feature's properties are stored as a map of JsonElement objects from kotlinx.serialization . A set of helper methods to get and set properties with the appropriate types directly. Kotlin val feature = Feature ( point ) feature . setNumberProperty ( \"size\" , 9999 ) val size : Number? = feature . getNumberProperty ( \"size\" ) // 9999 val geometry : Geometry? = feature . geometry // point JSON { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, \"properties\" : { \"size\" : 9999 } }","title":"Feature"},{"location":"geojson/#featurecollection","text":"A FeatureCollection is a collection of multiple features. FeatureCollection implements the Collection interface and can be used in any place that a collection can be used. Kotlin val featureCollection = FeatureCollection ( pointFeature ) featureCollection . forEach { feature -> // ... } JSON { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75 , 45 ] }, \"properties\" : { \"size\" : 9999 } } ] }","title":"FeatureCollection"},{"location":"geojson/#boundingbox","text":"The BoundingBox class is used to represent the bounding boxes that can be set for any GeoJson object. Like the Position class, bounding boxes are backed by a DoubleArray with each component accessible by its propery ( southwest and northeast ). Bounding boxes also support destructuring. Kotlin val bbox = BoundingBox ( west = 11.6 , south = 45.1 , east = 12.7 , north = 45.7 ) val ( southwest , northeast ) = bbox // Two Positions JSON [ 11.6 , 45.1 , 12.7 , 45.7 ]","title":"BoundingBox"},{"location":"geojson/#serialization","text":"Serialization is done using kotlinx.serialization and the serializer for any object listed above can be obtained using the static .serializer() method. The Geometry sealed class hierarchy uses a polymorphic serializer, so the serializer for all types of geometry are simply obtained from Geometry.serializer() .","title":"Serialization"},{"location":"geojson/#to-json","text":"Any GeoJson object can be serialized to Json using the json property. Kotlin val featureCollection : FeatureCollection = getFeatureCollection () val json = featureCollection . json println ( json )","title":"To Json"},{"location":"geojson/#from-json","text":"Json strings can be converted to GeoJson objects using various methods.","title":"From Json"},{"location":"geojson/#geometry_1","text":"Geometry can be converted from Json using generic functions that will automatically deserialize the given Json into the appropriate Geometry subclass. In Kotlin, these functions are available as extension functions on a String . In Java, these functions are available as static methods on GeometryFactory . Kotlin // Throws exception if the JSON cannot be deserialized to a Point val myPoint = \"{...geojson...}\" . toGeometry < Point > () // Returns null if an error occurs val nullable = \"{...not a point...}\" . toGeometryOrNull < Point > ()","title":"Geometry"},{"location":"geojson/#feature-and-featurecollection","text":"Feature and FeatureCollection objects can be converted from Json similarly. Kotlin val feature = \"{...feature...}\" . toFeature () val featureCollection = \"{...feature collection...}\" . toFeatureCollection ()","title":"Feature and FeatureCollection"},{"location":"geojson/#geojson-dsl","text":"It's recommended to construct GeoJson objects in-code using the included DSL.","title":"GeoJson DSL"},{"location":"geojson/#positions","text":"Convenience functions to construct latitude/longitude Position instances is included. These functions will check for valid latitude and longitude values and will throw an IllegalArgumentException otherwise. Kotlin lngLat ( longitude = - 75.0 , latitude = 45.0 ) // Throws exception!! lngLat ( longitude = - 565.0 , latitude = 45.0 ) JSON [ -75.0 , 45.0 ]","title":"Positions"},{"location":"geojson/#geometry_2","text":"Each geometry type has a corresponding DSL. A GeoJson object's bbox value can be assigned in any of the DSLs.","title":"Geometry"},{"location":"geojson/#point_1","text":"Kotlin point ( longitude = - 75.0 , latitude = 45.0 , altitude = 100.0 ) // Or... point ( Position ( 12.5 , 35.9 )) JSON { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] }","title":"Point"},{"location":"geojson/#multipoint_1","text":"The MultiPoint DSL uses the unary plus operator to add Position instances as positions in the geometry. Point geometries can also be added to the multi point using the unary plus operator. Kotlin multiPoint { + point ( - 75.0 , 45.0 ) + lngLat ( - 78.0 , 44.0 ) } JSON { \"type\" : \"MultiPoint\" , \"coordinates\" : [ [ -75.0 , 45.0 ], [ -78.0 , 44.0 ] ] }","title":"MultiPoint"},{"location":"geojson/#linestring_1","text":"Like with MultiPoint , the LineString DSL uses the unary plus operator to add positions as part of the line. The order in which positions are added to the LineString is the order that the LineString will follow. Kotlin lineString { + lngLat ( 45.0 , 45.0 ) + lngLat ( 0.0 , 0.0 ) } JSON { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] }","title":"LineString"},{"location":"geojson/#multilinestring_1","text":"The MultiLineString DSL uses the unary plus operator to add multiple line strings. The LineString DSL can be used to create LineString objects to add. Kotlin val simpleLine = lineString { + lngLat ( 45.0 , 45.0 ) + lngLat ( 0.0 , 0.0 ) } multiLineString { + simpleLine // Inline LineString creation + lineString { + lngLat ( 44.4 , 55.5 ) + lngLat ( 55.5 , 66.6 ) } } JSON { \"type\" : \"MultiLineString\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]], [[ 44.4 , 55.5 ], [ 55.5 , 66.6 ]] ] }","title":"MultiLineString"},{"location":"geojson/#polygon_1","text":"The Polygon DSL is used by specifying linear rings that make up the polygon's shape and holes. The first ring is the exterior ring with four or more positions. The last position must be the same as the first position. All ring s that follow will represent interior rings (i.e. holes) in the polygon. For convenience, the complete() function can be used to \"complete\" a ring. It adds the last position in the ring by copying the first position that was added. Kotlin val simpleLine = lineString { + lngLat ( 45.0 , 45.0 ) + lngLat ( 0.0 , 0.0 ) } polygon { ring { // LineStrings can be used as part of a ring + simpleLine + lngLat ( 12.0 , 12.0 ) complete () } ring { + lngLat ( 4.0 , 4.0 ) + lngLat ( 2.0 , 2.0 ) + lngLat ( 3.0 , 3.0 ) complete () } } JSON { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] }","title":"Polygon"},{"location":"geojson/#multipolygon_1","text":"Like with previous \"Multi\" geometries, the unary plus operator is used to add multiple Polygon objects. The Polygon DSL can also be used here. Kotlin val simplePolygon = previousExample () multiPolygon { + simplePolygon + polygon { ring { + LngLat ( 12.0 , 0.0 ) + LngLat ( 0.0 , 12.0 ) + LngLat ( - 12.0 , 0.0 ) + LngLat ( 5.0 , 5.0 ) complete () } } } JSON { \"type\" : \"MultiPolygon\" , \"coordinates\" : [ [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ], [ [[ 12.0 , 0.0 ], [ 0.0 , 12.0 ], [ -12.0 , 0.0 ], [ 5.0 , 5.0 ], [ 12.0 , 0.0 ]] ] ] }","title":"MultiPolygon"},{"location":"geojson/#geometry-collection","text":"The unary plus operator can be used to add any geometry instance to a GeometryCollection . Kotlin val simplePoint : Point = previousPoint () val simpleLine : LineString = previousLineString () val simplePolygon : Polygon = previousPolygon () geometryCollection { + simplePoint + simpleLine + simplePolygon } JSON { \"type\" : \"GeometryCollection\" , \"geometries\" : [ { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 , 100.0 ] }, { \"type\" : \"LineString\" , \"coordinates\" : [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ]] }, { \"type\" : \"Polygon\" , \"coordinates\" : [ [[ 45.0 , 45.0 ], [ 0.0 , 0.0 ], [ 12.0 , 12.0 ], [ 45.0 , 45.0 ]], [[ 4.0 , 4.0 ], [ 2.0 , 2.0 ], [ 3.0 , 3.0 ], [ 4.0 , 4.0 ]] ] } ] }","title":"Geometry Collection"},{"location":"geojson/#feature_1","text":"The Feature DSL can construct a Feature object with a geometry, a set of properties, a bounding box, and an id. Kotlin feature { geometry = point ( - 75.0 , 45.0 ) id = \"point1\" bbox = BoundingBox ( - 76.9 , 44.1 , - 74.2 , 45.7 ) properties { \"name\" to \"Hello World\" \"value\" to 13 \"cool\" to true } } JSON { \"type\" : \"Feature\" , \"id\" : \"point1\" , \"bbox\" : [ -76.9 , 44.1 , -74.2 , 45.7 ], \"properties\" : { \"name\" : \"Hello World\" , \"value\" : 13 , \"cool\" : true }, \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] } }","title":"Feature"},{"location":"geojson/#feature-collection","text":"A FeatureCollection is constructed by adding multiple Feature objects using the unary plus operator. Kotlin featureCollection { + feature { geometry = point ( - 75.0 , 45.0 ) } } JSON { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ -75.0 , 45.0 ] }, \"properties\" : {} } ] }","title":"Feature Collection"},{"location":"ported-functions/","text":"Ported Functions The following functions have been ported as of version 0.0.3-SNAPSHOT of this library. You can view porting progress for the next release here . Measurement along area bbox bboxPolygon bearing center centerOfMass destination distance envelope length midpoint pointOnFeature polygonTangents pointToLineDistance rhumbBearing rhumbDestination rhumbDistance square greatCircle Coordinate Mutation cleanCoords flip rewind round Use round or Math.round from the standard library instead. truncate Transformation bboxClip bezierSpline buffer circle clone concave convex difference dissolve intersect lineOffset simplify tessellate transformRotate transformTranslate transformScale union voronoi Feature Conversion combine explode flatten lineToPolygon polygonize polygonToLine Miscellaneous kinks lineArc lineChunk lineIntersect Partially implemented. lineOverlap lineSegment lineSlice lineSliceAlong lineSplit mask nearestPointOnLine sector shortestPath unkinkPolygon Helper Use the GeoJson DSL instead. Random randomPosition randomPoint randomLineString randomPolygon Data sample Interpolation interpolate isobands isolines planepoint tin Joins pointsWithinPolygon tag Grids hexGrid pointGrid squareGrid triangleGrid Classification nearestPoint Aggregation collect clustersDbscan clustersKmeans Meta coordAll coordEach coordReduce featureEach featureReduce flattenEach flattenReduce getCoord getCoords getGeom getType geomEach geomReduce propEach segmentEach segmentReduce getCluster clusterEach clusterReduce Assertations collectionOf containsNumber geojsonType featureOf Booleans booleanClockwise booleanContains booleanCrosses booleanDisjoint booleanEqual booleanOverlap booleanParallel booleanPointInPolygon booleanPointOnLine booleanWithin Unit Conversion bearingToAzimuth convertArea convertLength degreesToRadians lengthToRadians lengthToDegrees radiansToLength radiansToDegrees toMercator toWgs84","title":"Ported Functions"},{"location":"ported-functions/#ported-functions","text":"The following functions have been ported as of version 0.0.3-SNAPSHOT of this library. You can view porting progress for the next release here .","title":"Ported Functions"},{"location":"ported-functions/#measurement","text":"along area bbox bboxPolygon bearing center centerOfMass destination distance envelope length midpoint pointOnFeature polygonTangents pointToLineDistance rhumbBearing rhumbDestination rhumbDistance square greatCircle","title":"Measurement"},{"location":"ported-functions/#coordinate-mutation","text":"cleanCoords flip rewind round Use round or Math.round from the standard library instead. truncate","title":"Coordinate Mutation"},{"location":"ported-functions/#transformation","text":"bboxClip bezierSpline buffer circle clone concave convex difference dissolve intersect lineOffset simplify tessellate transformRotate transformTranslate transformScale union voronoi","title":"Transformation"},{"location":"ported-functions/#feature-conversion","text":"combine explode flatten lineToPolygon polygonize polygonToLine","title":"Feature Conversion"},{"location":"ported-functions/#miscellaneous","text":"kinks lineArc lineChunk lineIntersect Partially implemented. lineOverlap lineSegment lineSlice lineSliceAlong lineSplit mask nearestPointOnLine sector shortestPath unkinkPolygon","title":"Miscellaneous"},{"location":"ported-functions/#helper","text":"Use the GeoJson DSL instead.","title":"Helper"},{"location":"ported-functions/#random","text":"randomPosition randomPoint randomLineString randomPolygon","title":"Random"},{"location":"ported-functions/#data","text":"sample","title":"Data"},{"location":"ported-functions/#interpolation","text":"interpolate isobands isolines planepoint tin","title":"Interpolation"},{"location":"ported-functions/#joins","text":"pointsWithinPolygon tag","title":"Joins"},{"location":"ported-functions/#grids","text":"hexGrid pointGrid squareGrid triangleGrid","title":"Grids"},{"location":"ported-functions/#classification","text":"nearestPoint","title":"Classification"},{"location":"ported-functions/#aggregation","text":"collect clustersDbscan clustersKmeans","title":"Aggregation"},{"location":"ported-functions/#meta","text":"coordAll coordEach coordReduce featureEach featureReduce flattenEach flattenReduce getCoord getCoords getGeom getType geomEach geomReduce propEach segmentEach segmentReduce getCluster clusterEach clusterReduce","title":"Meta"},{"location":"ported-functions/#assertations","text":"collectionOf containsNumber geojsonType featureOf","title":"Assertations"},{"location":"ported-functions/#booleans","text":"booleanClockwise booleanContains booleanCrosses booleanDisjoint booleanEqual booleanOverlap booleanParallel booleanPointInPolygon booleanPointOnLine booleanWithin","title":"Booleans"},{"location":"ported-functions/#unit-conversion","text":"bearingToAzimuth convertArea convertLength degreesToRadians lengthToRadians lengthToDegrees radiansToLength radiansToDegrees toMercator toWgs84","title":"Unit Conversion"},{"location":"turf/","text":"Turf Turfjs is a spatial analysis library for JavaScript applications and the turf module contains a Kotlin port of it with support for Kotlin Multiplatform projects. This module makes use of the classes defined in the geojson module as the GeoJson inputs to many of the turf functions. The documentation for the ported functions can be found in the API docs , while more details on each function can be found on the Turfjs site. Installation Kotlin dependencies { implementation ( \"io.github.dellisd.spatialk:turf:<version>\" ) } Groovy dependencies { implementation \"io.github.dellisd.spatialk:turf:<version>\" } Example Turf functions are available as top-level functions in Kotlin, or as static member functions in Java. Kotlin val point = LngLat ( - 75.0 , 45.0 ) val ( longitude , latitude ) = destination ( point , 100.0 , 0.0 ) Turf Functions A list of all turf functions and their current status in the port can be found on this page . Units of Measurement Units of measurement are represented using the Units enum. These enum values can be passed into functions to specify the units used by other values passed into the function. Kotlin val result = convertLength ( 12.5 , from = Units . Kilometers , to = Units . Miles ) Not all units are valid for every function. For example: acres cannot be used as a measure of distance. Calling a function like convertLength with Units.Acres as one of the arguments will cause an IllegalArgumentException .","title":"Overview"},{"location":"turf/#turf","text":"Turfjs is a spatial analysis library for JavaScript applications and the turf module contains a Kotlin port of it with support for Kotlin Multiplatform projects. This module makes use of the classes defined in the geojson module as the GeoJson inputs to many of the turf functions. The documentation for the ported functions can be found in the API docs , while more details on each function can be found on the Turfjs site.","title":"Turf"},{"location":"turf/#installation","text":"Kotlin dependencies { implementation ( \"io.github.dellisd.spatialk:turf:<version>\" ) } Groovy dependencies { implementation \"io.github.dellisd.spatialk:turf:<version>\" }","title":"Installation"},{"location":"turf/#example","text":"Turf functions are available as top-level functions in Kotlin, or as static member functions in Java. Kotlin val point = LngLat ( - 75.0 , 45.0 ) val ( longitude , latitude ) = destination ( point , 100.0 , 0.0 )","title":"Example"},{"location":"turf/#turf-functions","text":"A list of all turf functions and their current status in the port can be found on this page .","title":"Turf Functions"},{"location":"turf/#units-of-measurement","text":"Units of measurement are represented using the Units enum. These enum values can be passed into functions to specify the units used by other values passed into the function. Kotlin val result = convertLength ( 12.5 , from = Units . Kilometers , to = Units . Miles ) Not all units are valid for every function. For example: acres cannot be used as a measure of distance. Calling a function like convertLength with Units.Acres as one of the arguments will cause an IllegalArgumentException .","title":"Units of Measurement"}]}